<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Cerata: cerata Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="cerata.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Cerata
   </div>
   <div id="projectbrief">A library to generate structural hardware designs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacecerata.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">cerata Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains every Cerata class, function, etc...  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcerata_1_1_bit.html">Bit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bit type.  <a href="structcerata_1_1_bit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcerata_1_1_boolean.html">Boolean</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structcerata_1_1_boolean.html" title="Boolean type.">Boolean</a> type.  <a href="structcerata_1_1_boolean.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcerata_1_1_clock_domain.html">ClockDomain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A clock domain.  <a href="structcerata_1_1_clock_domain.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_component.html">Component</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classcerata_1_1_component.html" title="A Component graph.">Component</a> graph.  <a href="classcerata_1_1_component.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_component_pool.html">ComponentPool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pool of Components.  <a href="classcerata_1_1_component_pool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_edge.html">Edge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A directed edge between two nodes.  <a href="classcerata_1_1_edge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_expression.html">Expression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A node representing a binary tree of other nodes.  <a href="classcerata_1_1_expression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcerata_1_1_flat_type.html">FlatType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A flattened type.  <a href="structcerata_1_1_flat_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_graph.html">Graph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A graph representing a hardware structure.  <a href="classcerata_1_1_graph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_instance.html">Instance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An instance.  <a href="classcerata_1_1_instance.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcerata_1_1_integer.html">Integer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structcerata_1_1_integer.html" title="Integer type.">Integer</a> type.  <a href="structcerata_1_1_integer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_literal.html">Literal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classcerata_1_1_literal.html" title="A Literal Node.">Literal</a> <a class="el" href="classcerata_1_1_node.html" title="A node.">Node</a>.  <a href="classcerata_1_1_literal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_logger.html">Logger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcerata_1_1_logger.html" title="Logger class.">Logger</a> class.  <a href="classcerata_1_1_logger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_mapping_matrix.html">MappingMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix used for <a class="el" href="classcerata_1_1_type_mapper.html" title="A structure to dynamically define type mappings between flattened types.">TypeMapper</a>.  <a href="classcerata_1_1_mapping_matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcerata_1_1_mapping_pair.html">MappingPair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure representing a mapping pair for a type mapping.  <a href="structcerata_1_1_mapping_pair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcerata_1_1_multi_output_node.html">MultiOutputNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="structcerata_1_1_multi_output_node.html" title="A MultiOutputNode is a Node that can drive multiple outputs.">MultiOutputNode</a> is a <a class="el" href="classcerata_1_1_node.html" title="A node.">Node</a> that can drive multiple outputs.  <a href="structcerata_1_1_multi_output_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcerata_1_1_named.html">Named</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience structure for anything that is named.  <a href="structcerata_1_1_named.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcerata_1_1_name_part.html">NamePart</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience struct to generate names in parts.  <a href="structcerata_1_1_name_part.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcerata_1_1_natural.html">Natural</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structcerata_1_1_natural.html" title="Natural type.">Natural</a> type.  <a href="structcerata_1_1_natural.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A node.  <a href="classcerata_1_1_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_node_array.html">NodeArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An array of nodes.  <a href="classcerata_1_1_node_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_node_pool.html">NodePool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pool of nodes.  <a href="classcerata_1_1_node_pool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcerata_1_1_normal_node.html">NormalNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="structcerata_1_1_normal_node.html" title="A NormalNode is a single-input, multiple-outputs node.">NormalNode</a> is a single-input, multiple-outputs node.  <a href="structcerata_1_1_normal_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcerata_1_1_nul.html">Nul</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Void type. Useful for e.g. empty streams.  <a href="structcerata_1_1_nul.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_object.html">Object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Cerata <a class="el" href="classcerata_1_1_object.html" title="A Cerata Object on a graph.">Object</a> on a graph.  <a href="classcerata_1_1_object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_output_generator.html">OutputGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class to generate language specific output from Graphs.  <a href="classcerata_1_1_output_generator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcerata_1_1_output_spec.html">OutputSpec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to specify output properties per graph.  <a href="structcerata_1_1_output_spec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_parameter.html">Parameter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classcerata_1_1_parameter.html" title="A Parameter node.">Parameter</a> node.  <a href="classcerata_1_1_parameter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_pool.html">Pool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pool to share ownership of objects.  <a href="classcerata_1_1_pool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcerata_1_1_port.html">Port</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A port is a terminator node on a graph.  <a href="structcerata_1_1_port.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_port_array.html">PortArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An array of port nodes.  <a href="classcerata_1_1_port_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_rec_field.html">RecField</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classcerata_1_1_record.html" title="A Record type containing zero or more RecordFields.">Record</a> field.  <a href="classcerata_1_1_rec_field.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_record.html">Record</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classcerata_1_1_record.html" title="A Record type containing zero or more RecordFields.">Record</a> type containing zero or more RecordFields.  <a href="classcerata_1_1_record.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_signal.html">Signal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classcerata_1_1_signal.html" title="A Signal Node.">Signal</a> <a class="el" href="classcerata_1_1_node.html" title="A node.">Node</a>.  <a href="classcerata_1_1_signal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_signal_array.html">SignalArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An array of signal nodes.  <a href="classcerata_1_1_signal_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_stream.html">Stream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classcerata_1_1_stream.html" title="A Stream type.">Stream</a> type.  <a href="classcerata_1_1_stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcerata_1_1_string.html">String</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structcerata_1_1_string.html" title="String type.">String</a> type.  <a href="structcerata_1_1_string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_synchronous.html">Synchronous</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to mark nodes with information for synchronous designs, e.g. clock domain.  <a href="classcerata_1_1_synchronous.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_term.html">Term</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A terminator structure to enable terminator sanity checks.  <a href="classcerata_1_1_term.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_type.html">Type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classcerata_1_1_type.html" title="A Type.">Type</a>.  <a href="classcerata_1_1_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_type_mapper.html">TypeMapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure to dynamically define type mappings between flattened types.  <a href="classcerata_1_1_type_mapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_type_pool.html">TypePool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pool of Types.  <a href="classcerata_1_1_type_pool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_vector.html">Vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcerata_1_1_vector.html" title="Vector type.">Vector</a> type.  <a href="classcerata_1_1_vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a3fcbbd525dac4039659ccb1f5a6bb256"><td class="memItemLeft" align="right" valign="top"><a id="a3fcbbd525dac4039659ccb1f5a6bb256"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a3fcbbd525dac4039659ccb1f5a6bb256">LogLevel</a> = int</td></tr>
<tr class="memdesc:a3fcbbd525dac4039659ccb1f5a6bb256"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcerata_1_1_type.html" title="A Type.">Type</a> used for the logging level. <br /></td></tr>
<tr class="separator:a3fcbbd525dac4039659ccb1f5a6bb256"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a54354555fa54fe1eb3a916d4e00b8103"><td class="memItemLeft" align="right" valign="top"><a id="a54354555fa54fe1eb3a916d4e00b8103"></a>
std::shared_ptr&lt; <a class="el" href="structcerata_1_1_clock_domain.html">ClockDomain</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a54354555fa54fe1eb3a916d4e00b8103">default_domain</a> ()</td></tr>
<tr class="memdesc:a54354555fa54fe1eb3a916d4e00b8103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a static default clock domain to be used in the whole design. <br /></td></tr>
<tr class="separator:a54354555fa54fe1eb3a916d4e00b8103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b87fba2894a37705b13a5557b474a88"><td class="memItemLeft" align="right" valign="top"><a id="a8b87fba2894a37705b13a5557b474a88"></a>
std::optional&lt; std::shared_ptr&lt; <a class="el" href="structcerata_1_1_clock_domain.html">ClockDomain</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a8b87fba2894a37705b13a5557b474a88">GetDomain</a> (const <a class="el" href="classcerata_1_1_node.html">Node</a> &amp;node)</td></tr>
<tr class="memdesc:a8b87fba2894a37705b13a5557b474a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the clock domain of a node, if it has one. <br /></td></tr>
<tr class="separator:a8b87fba2894a37705b13a5557b474a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a4a91a13db9c5da9a901069a1fa244"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcerata_1_1_edge.html">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a75a4a91a13db9c5da9a901069a1fa244">Connect</a> (<a class="el" href="classcerata_1_1_node.html">Node</a> *dst, <a class="el" href="classcerata_1_1_node.html">Node</a> *src)</td></tr>
<tr class="memdesc:a75a4a91a13db9c5da9a901069a1fa244"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect two nodes, returns the corresponding edge.  <a href="#a75a4a91a13db9c5da9a901069a1fa244">More...</a><br /></td></tr>
<tr class="separator:a75a4a91a13db9c5da9a901069a1fa244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac498abd92d47ff70c70b03a90aa60b6d"><td class="memItemLeft" align="right" valign="top"><a id="ac498abd92d47ff70c70b03a90aa60b6d"></a>
std::shared_ptr&lt; <a class="el" href="classcerata_1_1_edge.html">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#ac498abd92d47ff70c70b03a90aa60b6d">operator&lt;&lt;=</a> (<a class="el" href="classcerata_1_1_node.html">Node</a> *dst, const std::shared_ptr&lt; <a class="el" href="classcerata_1_1_node.html">Node</a> &gt; &amp;src)</td></tr>
<tr class="memdesc:ac498abd92d47ff70c70b03a90aa60b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an edge, connecting the src node to the dst node. <br /></td></tr>
<tr class="separator:ac498abd92d47ff70c70b03a90aa60b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5178cdef609eb5c4ab6c2a7af8f619a9"><td class="memItemLeft" align="right" valign="top"><a id="a5178cdef609eb5c4ab6c2a7af8f619a9"></a>
std::shared_ptr&lt; <a class="el" href="classcerata_1_1_edge.html">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a5178cdef609eb5c4ab6c2a7af8f619a9">operator&lt;&lt;=</a> (const std::weak_ptr&lt; <a class="el" href="classcerata_1_1_node.html">Node</a> &gt; &amp;dst, const std::weak_ptr&lt; <a class="el" href="classcerata_1_1_node.html">Node</a> &gt; &amp;src)</td></tr>
<tr class="memdesc:a5178cdef609eb5c4ab6c2a7af8f619a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an edge, connecting the src node to the dst node. <br /></td></tr>
<tr class="separator:a5178cdef609eb5c4ab6c2a7af8f619a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3487c1225d6eda2e1d283accbbffbd84"><td class="memItemLeft" align="right" valign="top"><a id="a3487c1225d6eda2e1d283accbbffbd84"></a>
std::shared_ptr&lt; <a class="el" href="classcerata_1_1_edge.html">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a3487c1225d6eda2e1d283accbbffbd84">operator&lt;&lt;=</a> (const std::weak_ptr&lt; <a class="el" href="classcerata_1_1_node.html">Node</a> &gt; &amp;dst, const std::shared_ptr&lt; <a class="el" href="classcerata_1_1_node.html">Node</a> &gt; &amp;src)</td></tr>
<tr class="memdesc:a3487c1225d6eda2e1d283accbbffbd84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an edge, connecting the src node to the dst node. <br /></td></tr>
<tr class="separator:a3487c1225d6eda2e1d283accbbffbd84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad10336e8259628bebb216f2d24755ec5"><td class="memItemLeft" align="right" valign="top"><a id="ad10336e8259628bebb216f2d24755ec5"></a>
std::shared_ptr&lt; <a class="el" href="classcerata_1_1_edge.html">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#ad10336e8259628bebb216f2d24755ec5">operator&lt;&lt;=</a> (const std::shared_ptr&lt; <a class="el" href="classcerata_1_1_node.html">Node</a> &gt; &amp;dst, const std::shared_ptr&lt; <a class="el" href="classcerata_1_1_node.html">Node</a> &gt; &amp;src)</td></tr>
<tr class="memdesc:ad10336e8259628bebb216f2d24755ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an edge, connecting the src node to the dst node. <br /></td></tr>
<tr class="separator:ad10336e8259628bebb216f2d24755ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fed11b092834b9c8ff3f05d9e45126a"><td class="memItemLeft" align="right" valign="top"><a id="a6fed11b092834b9c8ff3f05d9e45126a"></a>
std::shared_ptr&lt; <a class="el" href="classcerata_1_1_edge.html">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a6fed11b092834b9c8ff3f05d9e45126a">operator&lt;&lt;=</a> (const std::weak_ptr&lt; <a class="el" href="classcerata_1_1_node.html">Node</a> &gt; &amp;dst, <a class="el" href="classcerata_1_1_node.html">Node</a> *src)</td></tr>
<tr class="memdesc:a6fed11b092834b9c8ff3f05d9e45126a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an edge, connecting the src node to the dst node. <br /></td></tr>
<tr class="separator:a6fed11b092834b9c8ff3f05d9e45126a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68996ab5073433476cc9f08844a6f82"><td class="memItemLeft" align="right" valign="top"><a id="ac68996ab5073433476cc9f08844a6f82"></a>
std::deque&lt; <a class="el" href="classcerata_1_1_edge.html">Edge</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#ac68996ab5073433476cc9f08844a6f82">GetAllEdges</a> (const <a class="el" href="classcerata_1_1_graph.html">Graph</a> &amp;graph)</td></tr>
<tr class="memdesc:ac68996ab5073433476cc9f08844a6f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain all edges in a graph. <br /></td></tr>
<tr class="separator:ac68996ab5073433476cc9f08844a6f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d6ab1dbfe7c4f5cc3485b3430b4ff90"><td class="memItemLeft" align="right" valign="top"><a id="a5d6ab1dbfe7c4f5cc3485b3430b4ff90"></a>
std::shared_ptr&lt; <a class="el" href="classcerata_1_1_signal.html">Signal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a5d6ab1dbfe7c4f5cc3485b3430b4ff90">insert</a> (<a class="el" href="classcerata_1_1_edge.html">Edge</a> *edge, const std::string &amp;name_prefix=&quot;int_&quot;, std::optional&lt; <a class="el" href="classcerata_1_1_graph.html">Graph</a> * &gt; new_owner=std::nullopt)</td></tr>
<tr class="memdesc:a5d6ab1dbfe7c4f5cc3485b3430b4ff90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split an edge up to create two new edges with a signal node in the middle. Returns the new signal. <br /></td></tr>
<tr class="separator:a5d6ab1dbfe7c4f5cc3485b3430b4ff90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a566331b4acf7f5d9dbd78720f22447f8"><td class="memItemLeft" align="right" valign="top"><a id="a566331b4acf7f5d9dbd78720f22447f8"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a566331b4acf7f5d9dbd78720f22447f8">ToString</a> (<a class="el" href="classcerata_1_1_expression.html#ab9e0d7d014077b256215d4873ef47454">Expression::Op</a> operation)</td></tr>
<tr class="memdesc:a566331b4acf7f5d9dbd78720f22447f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Human-readable expression operator. <br /></td></tr>
<tr class="separator:a566331b4acf7f5d9dbd78720f22447f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff94e0deacf044a10e049e6693a451f"><td class="memItemLeft" align="right" valign="top"><a id="aeff94e0deacf044a10e049e6693a451f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#aeff94e0deacf044a10e049e6693a451f">operator&lt;</a> (const <a class="el" href="structcerata_1_1_flat_type.html">FlatType</a> &amp;a, const <a class="el" href="structcerata_1_1_flat_type.html">FlatType</a> &amp;b)</td></tr>
<tr class="memdesc:aeff94e0deacf044a10e049e6693a451f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two FlatTypes first by name, then by nesting level. Useful for sorting. <br /></td></tr>
<tr class="separator:aeff94e0deacf044a10e049e6693a451f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36a479d9e366a52134ebe4bce3242f6"><td class="memItemLeft" align="right" valign="top"><a id="af36a479d9e366a52134ebe4bce3242f6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#af36a479d9e366a52134ebe4bce3242f6">FlattenRecord</a> (std::deque&lt; <a class="el" href="structcerata_1_1_flat_type.html">FlatType</a> &gt; *list, const <a class="el" href="classcerata_1_1_record.html">Record</a> *record, const std::optional&lt; <a class="el" href="structcerata_1_1_flat_type.html">FlatType</a> &gt; &amp;parent, bool invert)</td></tr>
<tr class="memdesc:af36a479d9e366a52134ebe4bce3242f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flatten a <a class="el" href="classcerata_1_1_record.html" title="A Record type containing zero or more RecordFields.">Record</a>. <br /></td></tr>
<tr class="separator:af36a479d9e366a52134ebe4bce3242f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac24e4fb434dd82ef8eb207d752d18a4"><td class="memItemLeft" align="right" valign="top"><a id="aac24e4fb434dd82ef8eb207d752d18a4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#aac24e4fb434dd82ef8eb207d752d18a4">FlattenStream</a> (std::deque&lt; <a class="el" href="structcerata_1_1_flat_type.html">FlatType</a> &gt; *list, const <a class="el" href="classcerata_1_1_stream.html">Stream</a> *stream, const std::optional&lt; <a class="el" href="structcerata_1_1_flat_type.html">FlatType</a> &gt; &amp;parent, bool invert)</td></tr>
<tr class="memdesc:aac24e4fb434dd82ef8eb207d752d18a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flatten a <a class="el" href="classcerata_1_1_stream.html" title="A Stream type.">Stream</a>. <br /></td></tr>
<tr class="separator:aac24e4fb434dd82ef8eb207d752d18a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a590e73c96d2d46cb049d9f132052a7d3"><td class="memItemLeft" align="right" valign="top"><a id="a590e73c96d2d46cb049d9f132052a7d3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a590e73c96d2d46cb049d9f132052a7d3">Flatten</a> (std::deque&lt; <a class="el" href="structcerata_1_1_flat_type.html">FlatType</a> &gt; *list, <a class="el" href="classcerata_1_1_type.html">Type</a> *type, const std::optional&lt; <a class="el" href="structcerata_1_1_flat_type.html">FlatType</a> &gt; &amp;parent, const std::string &amp;name, bool invert, bool sep=true)</td></tr>
<tr class="memdesc:a590e73c96d2d46cb049d9f132052a7d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flatten any <a class="el" href="classcerata_1_1_type.html" title="A Type.">Type</a>. <br /></td></tr>
<tr class="separator:a590e73c96d2d46cb049d9f132052a7d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a31492313a3e7cb7b54cc4f845c113c"><td class="memItemLeft" align="right" valign="top"><a id="a4a31492313a3e7cb7b54cc4f845c113c"></a>
std::deque&lt; <a class="el" href="structcerata_1_1_flat_type.html">FlatType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a4a31492313a3e7cb7b54cc4f845c113c">Flatten</a> (<a class="el" href="classcerata_1_1_type.html">Type</a> *type)</td></tr>
<tr class="memdesc:a4a31492313a3e7cb7b54cc4f845c113c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flatten and return a list of FlatTypes. <br /></td></tr>
<tr class="separator:a4a31492313a3e7cb7b54cc4f845c113c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab729b72cb92bc42213fa6b8918f91281"><td class="memItemLeft" align="right" valign="top"><a id="ab729b72cb92bc42213fa6b8918f91281"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#ab729b72cb92bc42213fa6b8918f91281">ToString</a> (std::deque&lt; <a class="el" href="structcerata_1_1_flat_type.html">FlatType</a> &gt; flat_type_list)</td></tr>
<tr class="memdesc:ab729b72cb92bc42213fa6b8918f91281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a list of FlatTypes to a human-readable string. <br /></td></tr>
<tr class="separator:ab729b72cb92bc42213fa6b8918f91281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d5e4ac92d677a089114cb13aad8dc81"><td class="memItemLeft" align="right" valign="top"><a id="a2d5e4ac92d677a089114cb13aad8dc81"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a2d5e4ac92d677a089114cb13aad8dc81">ContainsFlatType</a> (const std::deque&lt; <a class="el" href="structcerata_1_1_flat_type.html">FlatType</a> &gt; &amp;flat_types_list, const <a class="el" href="classcerata_1_1_type.html">Type</a> *type)</td></tr>
<tr class="memdesc:a2d5e4ac92d677a089114cb13aad8dc81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if some <a class="el" href="classcerata_1_1_type.html" title="A Type.">Type</a> is contained in a list of FlatTypes, false otherwise. <br /></td></tr>
<tr class="separator:a2d5e4ac92d677a089114cb13aad8dc81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae18e22b2f50c0f0ae9b64d0a807a48c"><td class="memItemLeft" align="right" valign="top"><a id="aae18e22b2f50c0f0ae9b64d0a807a48c"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#aae18e22b2f50c0f0ae9b64d0a807a48c">IndexOfFlatType</a> (const std::deque&lt; <a class="el" href="structcerata_1_1_flat_type.html">FlatType</a> &gt; &amp;flat_types_list, const <a class="el" href="classcerata_1_1_type.html">Type</a> *type)</td></tr>
<tr class="memdesc:aae18e22b2f50c0f0ae9b64d0a807a48c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index of some <a class="el" href="classcerata_1_1_type.html" title="A Type.">Type</a> in a list of FlatTypes. <br /></td></tr>
<tr class="separator:aae18e22b2f50c0f0ae9b64d0a807a48c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa199912b79794ece2bf4f491251833d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaa199912b79794ece2bf4f491251833d"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecerata.html#aaa199912b79794ece2bf4f491251833d">RawValueOf</a> (const <a class="el" href="classcerata_1_1_literal.html">Literal</a> &amp;node)</td></tr>
<tr class="memdesc:aaa199912b79794ece2bf4f491251833d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the raw value of a literal node.  <a href="#aaa199912b79794ece2bf4f491251833d">More...</a><br /></td></tr>
<tr class="separator:aaa199912b79794ece2bf4f491251833d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f60d075cedc749be70a24d1b9226e04"><td class="memTemplParams" colspan="2"><a id="a2f60d075cedc749be70a24d1b9226e04"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a2f60d075cedc749be70a24d1b9226e04"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a2f60d075cedc749be70a24d1b9226e04">RawValueOf</a> (const <a class="el" href="classcerata_1_1_literal.html">Literal</a> &amp;node)</td></tr>
<tr class="memdesc:a2f60d075cedc749be70a24d1b9226e04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization for RawValueOf&lt;bool&gt; <br /></td></tr>
<tr class="separator:a2f60d075cedc749be70a24d1b9226e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfcc90576bf5c0b68120fc58771d6af8"><td class="memTemplParams" colspan="2"><a id="acfcc90576bf5c0b68120fc58771d6af8"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:acfcc90576bf5c0b68120fc58771d6af8"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecerata.html#acfcc90576bf5c0b68120fc58771d6af8">RawValueOf</a> (const <a class="el" href="classcerata_1_1_literal.html">Literal</a> &amp;node)</td></tr>
<tr class="memdesc:acfcc90576bf5c0b68120fc58771d6af8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization for RawValueOf&lt;int&gt; <br /></td></tr>
<tr class="separator:acfcc90576bf5c0b68120fc58771d6af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed3d124db6df73c0acdb6b6191a59cf"><td class="memTemplParams" colspan="2"><a id="a6ed3d124db6df73c0acdb6b6191a59cf"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a6ed3d124db6df73c0acdb6b6191a59cf"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a6ed3d124db6df73c0acdb6b6191a59cf">RawValueOf</a> (const <a class="el" href="classcerata_1_1_literal.html">Literal</a> &amp;node)</td></tr>
<tr class="memdesc:a6ed3d124db6df73c0acdb6b6191a59cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization for <a class="el" href="namespacecerata.html#aaa199912b79794ece2bf4f491251833d" title="Obtain the raw value of a literal node.">RawValueOf&lt;std::string&gt;</a> <br /></td></tr>
<tr class="separator:a6ed3d124db6df73c0acdb6b6191a59cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a709d4b62709694510baba580d4910c34"><td class="memTemplParams" colspan="2"><a id="a709d4b62709694510baba580d4910c34"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a709d4b62709694510baba580d4910c34"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcerata_1_1_literal.html#a83d47bb3ef158318cb12ee577a999899">Literal::StorageType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a709d4b62709694510baba580d4910c34">StorageTypeOf</a> ()</td></tr>
<tr class="memdesc:a709d4b62709694510baba580d4910c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the <a class="el" href="classcerata_1_1_literal.html#a83d47bb3ef158318cb12ee577a999899" title="The storage type of the literal value.">Literal::StorageType</a> enum value of a C++ type T. <br /></td></tr>
<tr class="separator:a709d4b62709694510baba580d4910c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a27f27d87e6f67ef9efbfa114f7f33d"><td class="memTemplParams" colspan="2"><a id="a7a27f27d87e6f67ef9efbfa114f7f33d"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a7a27f27d87e6f67ef9efbfa114f7f33d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcerata_1_1_literal.html#a83d47bb3ef158318cb12ee577a999899">Literal::StorageType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a7a27f27d87e6f67ef9efbfa114f7f33d">StorageTypeOf&lt; bool &gt;</a> ()</td></tr>
<tr class="memdesc:a7a27f27d87e6f67ef9efbfa114f7f33d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization for StorageTypeOf&lt;bool&gt; <br /></td></tr>
<tr class="separator:a7a27f27d87e6f67ef9efbfa114f7f33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a741fafc33cf434aadddaa5db4b3bfcf4"><td class="memTemplParams" colspan="2"><a id="a741fafc33cf434aadddaa5db4b3bfcf4"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a741fafc33cf434aadddaa5db4b3bfcf4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcerata_1_1_literal.html#a83d47bb3ef158318cb12ee577a999899">Literal::StorageType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a741fafc33cf434aadddaa5db4b3bfcf4">StorageTypeOf&lt; int &gt;</a> ()</td></tr>
<tr class="memdesc:a741fafc33cf434aadddaa5db4b3bfcf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization for StorageTypeOf&lt;int&gt; <br /></td></tr>
<tr class="separator:a741fafc33cf434aadddaa5db4b3bfcf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20aa01333e4b6affc07c3e40b1e64aa9"><td class="memTemplParams" colspan="2"><a id="a20aa01333e4b6affc07c3e40b1e64aa9"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a20aa01333e4b6affc07c3e40b1e64aa9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcerata_1_1_literal.html#a83d47bb3ef158318cb12ee577a999899">Literal::StorageType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a20aa01333e4b6affc07c3e40b1e64aa9">StorageTypeOf&lt; std::string &gt;</a> ()</td></tr>
<tr class="memdesc:a20aa01333e4b6affc07c3e40b1e64aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization for <a class="el" href="namespacecerata.html#a709d4b62709694510baba580d4910c34" title="Obtain the Literal::StorageType enum value of a C++ type T.">StorageTypeOf&lt;std::string&gt;</a> <br /></td></tr>
<tr class="separator:a20aa01333e4b6affc07c3e40b1e64aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac4f24d9dec464f3964bb7923ae0a79"><td class="memItemLeft" align="right" valign="top"><a id="a2ac4f24d9dec464f3964bb7923ae0a79"></a>
<a class="el" href="classcerata_1_1_logger.html">Logger</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a2ac4f24d9dec464f3964bb7923ae0a79">logger</a> ()</td></tr>
<tr class="memdesc:a2ac4f24d9dec464f3964bb7923ae0a79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the global Cerata logger. <br /></td></tr>
<tr class="separator:a2ac4f24d9dec464f3964bb7923ae0a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2146118ea4459675bc1bf0879db28fc2"><td class="memItemLeft" align="right" valign="top"><a id="a2146118ea4459675bc1bf0879db28fc2"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a2146118ea4459675bc1bf0879db28fc2">ToString</a> (<a class="el" href="classcerata_1_1_node.html#a648f249ae6714826366a329ac33730c0">Node::NodeID</a> id)</td></tr>
<tr class="memdesc:a2146118ea4459675bc1bf0879db28fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a <a class="el" href="classcerata_1_1_node.html" title="A node.">Node</a> ID to a human-readable string. <br /></td></tr>
<tr class="separator:a2146118ea4459675bc1bf0879db28fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b5f9afe961078b8fa4353707433ce7"><td class="memItemLeft" align="right" valign="top"><a id="a07b5f9afe961078b8fa4353707433ce7"></a>
<a class="el" href="classcerata_1_1_type_pool.html">TypePool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a07b5f9afe961078b8fa4353707433ce7">default_type_pool</a> ()</td></tr>
<tr class="memdesc:a07b5f9afe961078b8fa4353707433ce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a global default <a class="el" href="classcerata_1_1_type_pool.html" title="A pool of Types.">TypePool</a>. <br /></td></tr>
<tr class="separator:a07b5f9afe961078b8fa4353707433ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5507f0a68a372e488c19f4f194fefffd"><td class="memItemLeft" align="right" valign="top"><a id="a5507f0a68a372e488c19f4f194fefffd"></a>
<a class="el" href="classcerata_1_1_component_pool.html">ComponentPool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a5507f0a68a372e488c19f4f194fefffd">default_component_pool</a> ()</td></tr>
<tr class="memdesc:a5507f0a68a372e488c19f4f194fefffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a global default component pool. <br /></td></tr>
<tr class="separator:a5507f0a68a372e488c19f4f194fefffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb8d91dc1beab21a259e6d40e3641ac7"><td class="memItemLeft" align="right" valign="top"><a id="acb8d91dc1beab21a259e6d40e3641ac7"></a>
<a class="el" href="classcerata_1_1_node_pool.html">NodePool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#acb8d91dc1beab21a259e6d40e3641ac7">default_node_pool</a> ()</td></tr>
<tr class="memdesc:acb8d91dc1beab21a259e6d40e3641ac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a global default node pool that can store nodes without being owned by a graph. <br /></td></tr>
<tr class="separator:acb8d91dc1beab21a259e6d40e3641ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ec80fab8724bc760787ef0b67e9cfa"><td class="memItemLeft" align="right" valign="top"><a id="a39ec80fab8724bc760787ef0b67e9cfa"></a>
<a class="el" href="classcerata_1_1_literal.html">Literal</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a39ec80fab8724bc760787ef0b67e9cfa">rintl</a> (int i)</td></tr>
<tr class="memdesc:a39ec80fab8724bc760787ef0b67e9cfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a raw pointer to an integer literal from the default node pool. <br /></td></tr>
<tr class="separator:a39ec80fab8724bc760787ef0b67e9cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c312f1ca9298bcfa0a2e828ddfd4e78"><td class="memItemLeft" align="right" valign="top"><a id="a8c312f1ca9298bcfa0a2e828ddfd4e78"></a>
std::shared_ptr&lt; <a class="el" href="classcerata_1_1_literal.html">Literal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a8c312f1ca9298bcfa0a2e828ddfd4e78">intl</a> (int i)</td></tr>
<tr class="memdesc:a8c312f1ca9298bcfa0a2e828ddfd4e78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a shared pointer to an integer literal from the default node pool. <br /></td></tr>
<tr class="separator:a8c312f1ca9298bcfa0a2e828ddfd4e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b0bad258fc1372554a5c5c1bec86e63"><td class="memItemLeft" align="right" valign="top"><a id="a4b0bad258fc1372554a5c5c1bec86e63"></a>
<a class="el" href="classcerata_1_1_literal.html">Literal</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a4b0bad258fc1372554a5c5c1bec86e63">rstrl</a> (std::string str)</td></tr>
<tr class="memdesc:a4b0bad258fc1372554a5c5c1bec86e63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a raw pointer to a string literal from the default node pool. <br /></td></tr>
<tr class="separator:a4b0bad258fc1372554a5c5c1bec86e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c8c87100d50ab58df7b038f2db56e9"><td class="memItemLeft" align="right" valign="top"><a id="a82c8c87100d50ab58df7b038f2db56e9"></a>
std::shared_ptr&lt; <a class="el" href="classcerata_1_1_literal.html">Literal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a82c8c87100d50ab58df7b038f2db56e9">strl</a> (std::string str)</td></tr>
<tr class="memdesc:a82c8c87100d50ab58df7b038f2db56e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a shared pointer to a string literal from the default node pool. <br /></td></tr>
<tr class="separator:a82c8c87100d50ab58df7b038f2db56e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988e27720b998e85472d3e1b198a21be"><td class="memItemLeft" align="right" valign="top"><a id="a988e27720b998e85472d3e1b198a21be"></a>
std::shared_ptr&lt; <a class="el" href="classcerata_1_1_literal.html">Literal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a988e27720b998e85472d3e1b198a21be">booll</a> (bool value)</td></tr>
<tr class="memdesc:a988e27720b998e85472d3e1b198a21be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a literal node representing a <a class="el" href="structcerata_1_1_boolean.html" title="Boolean type.">Boolean</a>. <br /></td></tr>
<tr class="separator:a988e27720b998e85472d3e1b198a21be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b4f61a26d8d7097418767a47a98bdf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#aa7b4f61a26d8d7097418767a47a98bdf">GetAllGraphs</a> (<a class="el" href="classcerata_1_1_graph.html">Graph</a> *top_graph, std::deque&lt; <a class="el" href="classcerata_1_1_graph.html">Graph</a> * &gt; *graphs_out, bool include_components=false)</td></tr>
<tr class="memdesc:aa7b4f61a26d8d7097418767a47a98bdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all potential child graphs of a graph.  <a href="#aa7b4f61a26d8d7097418767a47a98bdf">More...</a><br /></td></tr>
<tr class="separator:aa7b4f61a26d8d7097418767a47a98bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1b8dea530ec708a9ed6e04d0b60a63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#abc1b8dea530ec708a9ed6e04d0b60a63">GetAllObjects</a> (<a class="el" href="classcerata_1_1_component.html">Component</a> *top_component, std::deque&lt; <a class="el" href="classcerata_1_1_object.html">Object</a> * &gt; *objects_out, bool include_instances=false)</td></tr>
<tr class="memdesc:abc1b8dea530ec708a9ed6e04d0b60a63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all objects from a component.  <a href="#abc1b8dea530ec708a9ed6e04d0b60a63">More...</a><br /></td></tr>
<tr class="separator:abc1b8dea530ec708a9ed6e04d0b60a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c5908fb2f9d59e569949bc4b376582"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a01c5908fb2f9d59e569949bc4b376582">GetAllTypes</a> (<a class="el" href="classcerata_1_1_component.html">Component</a> *top_component, std::deque&lt; <a class="el" href="classcerata_1_1_type.html">Type</a> * &gt; *types_out, bool include_instances=false)</td></tr>
<tr class="memdesc:a01c5908fb2f9d59e569949bc4b376582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all types used in a component, including nested types.  <a href="#a01c5908fb2f9d59e569949bc4b376582">More...</a><br /></td></tr>
<tr class="separator:a01c5908fb2f9d59e569949bc4b376582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f38b2ef008ba32334c8708acc7e9208"><td class="memItemLeft" align="right" valign="top"><a id="a7f38b2ef008ba32334c8708acc7e9208"></a>
std::shared_ptr&lt; <a class="el" href="classcerata_1_1_type.html">Type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a7f38b2ef008ba32334c8708acc7e9208">bit</a> ()</td></tr>
<tr class="memdesc:a7f38b2ef008ba32334c8708acc7e9208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a generic static <a class="el" href="structcerata_1_1_bit.html" title="A bit type.">Bit</a> type. <br /></td></tr>
<tr class="separator:a7f38b2ef008ba32334c8708acc7e9208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af57bf22016f14347ae342e0773a806d7"><td class="memItemLeft" align="right" valign="top"><a id="af57bf22016f14347ae342e0773a806d7"></a>
std::shared_ptr&lt; <a class="el" href="classcerata_1_1_type.html">Type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#af57bf22016f14347ae342e0773a806d7">nul</a> ()</td></tr>
<tr class="memdesc:af57bf22016f14347ae342e0773a806d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a static <a class="el" href="structcerata_1_1_nul.html" title="Void type. Useful for e.g. empty streams.">Nul</a> type. <br /></td></tr>
<tr class="separator:af57bf22016f14347ae342e0773a806d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25c6ab0d58cb51648b0930d72c21276"><td class="memItemLeft" align="right" valign="top"><a id="aa25c6ab0d58cb51648b0930d72c21276"></a>
std::shared_ptr&lt; <a class="el" href="classcerata_1_1_type.html">Type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#aa25c6ab0d58cb51648b0930d72c21276">string</a> ()</td></tr>
<tr class="memdesc:aa25c6ab0d58cb51648b0930d72c21276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic static <a class="el" href="structcerata_1_1_string.html" title="String type.">String</a> type. <br /></td></tr>
<tr class="separator:aa25c6ab0d58cb51648b0930d72c21276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84850e14c4b37fa654fee0df615abe28"><td class="memItemLeft" align="right" valign="top"><a id="a84850e14c4b37fa654fee0df615abe28"></a>
std::shared_ptr&lt; <a class="el" href="classcerata_1_1_type.html">Type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a84850e14c4b37fa654fee0df615abe28">integer</a> ()</td></tr>
<tr class="memdesc:a84850e14c4b37fa654fee0df615abe28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a generic static <a class="el" href="structcerata_1_1_integer.html" title="Integer type.">Integer</a> type. <br /></td></tr>
<tr class="separator:a84850e14c4b37fa654fee0df615abe28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d69ae6d560ff5778131bb4e5008ed9"><td class="memItemLeft" align="right" valign="top"><a id="a97d69ae6d560ff5778131bb4e5008ed9"></a>
std::shared_ptr&lt; <a class="el" href="classcerata_1_1_type.html">Type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a97d69ae6d560ff5778131bb4e5008ed9">natural</a> ()</td></tr>
<tr class="memdesc:a97d69ae6d560ff5778131bb4e5008ed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a generic static <a class="el" href="structcerata_1_1_integer.html" title="Integer type.">Integer</a> type. <br /></td></tr>
<tr class="separator:a97d69ae6d560ff5778131bb4e5008ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38baea85be258c82ebae0316cbec0e07"><td class="memItemLeft" align="right" valign="top"><a id="a38baea85be258c82ebae0316cbec0e07"></a>
std::shared_ptr&lt; <a class="el" href="classcerata_1_1_type.html">Type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a38baea85be258c82ebae0316cbec0e07">boolean</a> ()</td></tr>
<tr class="memdesc:a38baea85be258c82ebae0316cbec0e07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic static <a class="el" href="structcerata_1_1_boolean.html" title="Boolean type.">Boolean</a> type. <br /></td></tr>
<tr class="separator:a38baea85be258c82ebae0316cbec0e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a1242542c05bab3a6240946f33ad78c"><td class="memItemLeft" align="right" valign="top"><a id="a6a1242542c05bab3a6240946f33ad78c"></a>
std::shared_ptr&lt; <a class="el" href="classcerata_1_1_rec_field.html">RecField</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a6a1242542c05bab3a6240946f33ad78c">NoSep</a> (std::shared_ptr&lt; <a class="el" href="classcerata_1_1_rec_field.html">RecField</a> &gt; field)</td></tr>
<tr class="memdesc:a6a1242542c05bab3a6240946f33ad78c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to disable the seperator for a record field. <br /></td></tr>
<tr class="separator:a6a1242542c05bab3a6240946f33ad78c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae290cf0a3c1ebde410ce12c900ca7743"><td class="memItemLeft" align="right" valign="top"><a id="ae290cf0a3c1ebde410ce12c900ca7743"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#ae290cf0a3c1ebde410ce12c900ca7743">ToString</a> (const std::unordered_map&lt; std::string, std::string &gt; &amp;meta)</td></tr>
<tr class="memdesc:ae290cf0a3c1ebde410ce12c900ca7743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a human-readable representation of an unordered map of string key-value pairs. <br /></td></tr>
<tr class="separator:ae290cf0a3c1ebde410ce12c900ca7743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5e023bf7fa158ab1719f34bea69232"><td class="memItemLeft" align="right" valign="top"><a id="a5a5e023bf7fa158ab1719f34bea69232"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a5a5e023bf7fa158ab1719f34bea69232">CreateDir</a> (const std::string &amp;dir_name)</td></tr>
<tr class="memdesc:a5a5e023bf7fa158ab1719f34bea69232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a directory. <br /></td></tr>
<tr class="separator:a5a5e023bf7fa158ab1719f34bea69232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d99ff165c6a0643187e19cfc324048e"><td class="memItemLeft" align="right" valign="top"><a id="a8d99ff165c6a0643187e19cfc324048e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a8d99ff165c6a0643187e19cfc324048e">FileExists</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a8d99ff165c6a0643187e19cfc324048e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if file exists. <br /></td></tr>
<tr class="separator:a8d99ff165c6a0643187e19cfc324048e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1460864427a8c61e7780b31edb5229c8"><td class="memTemplParams" colspan="2"><a id="a1460864427a8c61e7780b31edb5229c8"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1460864427a8c61e7780b31edb5229c8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a1460864427a8c61e7780b31edb5229c8">Contains</a> (const std::deque&lt; std::shared_ptr&lt; T &gt;&gt; &amp;list, const std::shared_ptr&lt; T &gt; &amp;item)</td></tr>
<tr class="memdesc:a1460864427a8c61e7780b31edb5229c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if list contains item, false otherwise. <br /></td></tr>
<tr class="separator:a1460864427a8c61e7780b31edb5229c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71edded0d76fd56e74ba45eb9dd128b"><td class="memTemplParams" colspan="2"><a id="ab71edded0d76fd56e74ba45eb9dd128b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab71edded0d76fd56e74ba45eb9dd128b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecerata.html#ab71edded0d76fd56e74ba45eb9dd128b">Contains</a> (const std::deque&lt; std::weak_ptr&lt; T &gt;&gt; &amp;list, const std::weak_ptr&lt; T &gt; &amp;item)</td></tr>
<tr class="memdesc:ab71edded0d76fd56e74ba45eb9dd128b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if list contains item, false otherwise. <br /></td></tr>
<tr class="separator:ab71edded0d76fd56e74ba45eb9dd128b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c2136f6574edcf42bcb098113925a6"><td class="memTemplParams" colspan="2"><a id="a87c2136f6574edcf42bcb098113925a6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a87c2136f6574edcf42bcb098113925a6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a87c2136f6574edcf42bcb098113925a6">Contains</a> (const std::deque&lt; T * &gt; &amp;list, T *item)</td></tr>
<tr class="memdesc:a87c2136f6574edcf42bcb098113925a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if list contains item, false otherwise. <br /></td></tr>
<tr class="separator:a87c2136f6574edcf42bcb098113925a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff5aae484d36c0b0b26d226e89945ca5"><td class="memTemplParams" colspan="2"><a id="aff5aae484d36c0b0b26d226e89945ca5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aff5aae484d36c0b0b26d226e89945ca5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecerata.html#aff5aae484d36c0b0b26d226e89945ca5">Append</a> (std::deque&lt; std::shared_ptr&lt; T &gt;&gt; *list_a, const std::deque&lt; std::shared_ptr&lt; T &gt;&gt; &amp;list_b)</td></tr>
<tr class="memdesc:aff5aae484d36c0b0b26d226e89945ca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append list b to list a. <br /></td></tr>
<tr class="separator:aff5aae484d36c0b0b26d226e89945ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae886cbb753ff63f6a98fd338fe887dac"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae886cbb753ff63f6a98fd338fe887dac"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecerata.html#ae886cbb753ff63f6a98fd338fe887dac">Remove</a> (std::deque&lt; std::shared_ptr&lt; T &gt;&gt; *list, const std::shared_ptr&lt; T &gt; &amp;item)</td></tr>
<tr class="memdesc:ae886cbb753ff63f6a98fd338fe887dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an item from a deque, returning false if it was not in the deque, true otherwise.  <a href="#ae886cbb753ff63f6a98fd338fe887dac">More...</a><br /></td></tr>
<tr class="separator:ae886cbb753ff63f6a98fd338fe887dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c2f514434950d956373e060498c2d22"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6c2f514434950d956373e060498c2d22"><td class="memTemplItemLeft" align="right" valign="top">std::deque&lt; T * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a6c2f514434950d956373e060498c2d22">ToRawPointers</a> (const std::deque&lt; std::shared_ptr&lt; T &gt;&gt; &amp;list)</td></tr>
<tr class="memdesc:a6c2f514434950d956373e060498c2d22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a list of shared pointers to raw pointers.  <a href="#a6c2f514434950d956373e060498c2d22">More...</a><br /></td></tr>
<tr class="separator:a6c2f514434950d956373e060498c2d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebdc6582879f663d160513ad82388086"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aebdc6582879f663d160513ad82388086"><td class="memTemplItemLeft" align="right" valign="top">std::deque&lt; T * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecerata.html#aebdc6582879f663d160513ad82388086">ToRawPointers</a> (const std::deque&lt; std::unique_ptr&lt; T &gt;&gt; &amp;list)</td></tr>
<tr class="memdesc:aebdc6582879f663d160513ad82388086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a list of unique pointers to raw pointers.  <a href="#aebdc6582879f663d160513ad82388086">More...</a><br /></td></tr>
<tr class="separator:aebdc6582879f663d160513ad82388086"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a5cb5dc84674f8863f61b2a997181ce91"><td class="memItemLeft" align="right" valign="top"><a id="a5cb5dc84674f8863f61b2a997181ce91"></a>
constexpr <a class="el" href="namespacecerata.html#a3fcbbd525dac4039659ccb1f5a6bb256">LogLevel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a5cb5dc84674f8863f61b2a997181ce91">CERATA_LOG_DEBUG</a> = -1</td></tr>
<tr class="memdesc:a5cb5dc84674f8863f61b2a997181ce91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debug level. <br /></td></tr>
<tr class="separator:a5cb5dc84674f8863f61b2a997181ce91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4870ffebda0cabb4058799d58ad9f8ae"><td class="memItemLeft" align="right" valign="top"><a id="a4870ffebda0cabb4058799d58ad9f8ae"></a>
constexpr <a class="el" href="namespacecerata.html#a3fcbbd525dac4039659ccb1f5a6bb256">LogLevel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a4870ffebda0cabb4058799d58ad9f8ae">CERATA_LOG_INFO</a> = 0</td></tr>
<tr class="memdesc:a4870ffebda0cabb4058799d58ad9f8ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information level. <br /></td></tr>
<tr class="separator:a4870ffebda0cabb4058799d58ad9f8ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db829eebdd52ddd870f9cda54348999"><td class="memItemLeft" align="right" valign="top"><a id="a4db829eebdd52ddd870f9cda54348999"></a>
constexpr <a class="el" href="namespacecerata.html#a3fcbbd525dac4039659ccb1f5a6bb256">LogLevel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a4db829eebdd52ddd870f9cda54348999">CERATA_LOG_WARNING</a> = 1</td></tr>
<tr class="memdesc:a4db829eebdd52ddd870f9cda54348999"><td class="mdescLeft">&#160;</td><td class="mdescRight">Warning level. <br /></td></tr>
<tr class="separator:a4db829eebdd52ddd870f9cda54348999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f306c2e65e0519ee17f38a9e33797d"><td class="memItemLeft" align="right" valign="top"><a id="a22f306c2e65e0519ee17f38a9e33797d"></a>
constexpr <a class="el" href="namespacecerata.html#a3fcbbd525dac4039659ccb1f5a6bb256">LogLevel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a22f306c2e65e0519ee17f38a9e33797d">CERATA_LOG_ERROR</a> = 2</td></tr>
<tr class="memdesc:a22f306c2e65e0519ee17f38a9e33797d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error level. <br /></td></tr>
<tr class="separator:a22f306c2e65e0519ee17f38a9e33797d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a218dc6a092b811483542ed281081b966"><td class="memItemLeft" align="right" valign="top"><a id="a218dc6a092b811483542ed281081b966"></a>
constexpr <a class="el" href="namespacecerata.html#a3fcbbd525dac4039659ccb1f5a6bb256">LogLevel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a218dc6a092b811483542ed281081b966">CERATA_LOG_FATAL</a> = 3</td></tr>
<tr class="memdesc:a218dc6a092b811483542ed281081b966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fatal level; tool should exit. <br /></td></tr>
<tr class="separator:a218dc6a092b811483542ed281081b966"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains every Cerata class, function, etc... </p>
<p>Contains everything related to the VHDL back-end.</p>
<p>Contains everything related to the DOT back-end. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a75a4a91a13db9c5da9a901069a1fa244"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75a4a91a13db9c5da9a901069a1fa244">&#9670;&nbsp;</a></span>Connect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classcerata_1_1_edge.html">Edge</a> &gt; cerata::Connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcerata_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcerata_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect two nodes, returns the corresponding edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The destination node. </td></tr>
    <tr><td class="paramname">src</td><td>The source node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The edge connecting the nodes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="edge_8cc_source.html#l00067">67</a> of file <a class="el" href="edge_8cc_source.html">edge.cc</a>.</p>

</div>
</div>
<a id="aa7b4f61a26d8d7097418767a47a98bdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7b4f61a26d8d7097418767a47a98bdf">&#9670;&nbsp;</a></span>GetAllGraphs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cerata::GetAllGraphs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcerata_1_1_graph.html">Graph</a> *&#160;</td>
          <td class="paramname"><em>top_graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::deque&lt; <a class="el" href="classcerata_1_1_graph.html">Graph</a> * &gt; *&#160;</td>
          <td class="paramname"><em>graphs_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_components</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all potential child graphs of a graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">top_graph</td><td>The top-level graph to inspect. </td></tr>
    <tr><td class="paramname">graphs_out</td><td>A list of graphs to append the output to. </td></tr>
    <tr><td class="paramname">include_components</td><td>Whether to recurse down the components used by any instances in the graph. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="transform_8cc_source.html#l00027">27</a> of file <a class="el" href="transform_8cc_source.html">transform.cc</a>.</p>

</div>
</div>
<a id="abc1b8dea530ec708a9ed6e04d0b60a63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc1b8dea530ec708a9ed6e04d0b60a63">&#9670;&nbsp;</a></span>GetAllObjects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cerata::GetAllObjects </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcerata_1_1_component.html">Component</a> *&#160;</td>
          <td class="paramname"><em>top_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::deque&lt; <a class="el" href="classcerata_1_1_object.html">Object</a> * &gt; *&#160;</td>
          <td class="paramname"><em>objects_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_instances</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all objects from a component. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">top_component</td><td>The top-level component to inspect. </td></tr>
    <tr><td class="paramname">objects_out</td><td>A list of objects to append the output to. </td></tr>
    <tr><td class="paramname">include_instances</td><td>Whether to recurse down the instances in the top-level graph. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="transform_8cc_source.html#l00048">48</a> of file <a class="el" href="transform_8cc_source.html">transform.cc</a>.</p>

</div>
</div>
<a id="a01c5908fb2f9d59e569949bc4b376582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01c5908fb2f9d59e569949bc4b376582">&#9670;&nbsp;</a></span>GetAllTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cerata::GetAllTypes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcerata_1_1_component.html">Component</a> *&#160;</td>
          <td class="paramname"><em>top_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::deque&lt; <a class="el" href="classcerata_1_1_type.html">Type</a> * &gt; *&#160;</td>
          <td class="paramname"><em>types_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_instances</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all types used in a component, including nested types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">top_component</td><td>The top-level component to inspect. </td></tr>
    <tr><td class="paramname">types_out</td><td>A list of types to append the output to. </td></tr>
    <tr><td class="paramname">include_instances</td><td>Whether to recurse down the instances in the top-level graph. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="transform_8cc_source.html#l00061">61</a> of file <a class="el" href="transform_8cc_source.html">transform.cc</a>.</p>

</div>
</div>
<a id="aaa199912b79794ece2bf4f491251833d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa199912b79794ece2bf4f491251833d">&#9670;&nbsp;</a></span>RawValueOf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T cerata::RawValueOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcerata_1_1_literal.html">Literal</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the raw value of a literal node. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The compile-time return type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node to obtain the value from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of type T. </dd></dl>

<p class="definition">Definition at line <a class="el" href="literal_8h_source.html#l00110">110</a> of file <a class="el" href="literal_8h_source.html">literal.h</a>.</p>

</div>
</div>
<a id="ae886cbb753ff63f6a98fd338fe887dac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae886cbb753ff63f6a98fd338fe887dac">&#9670;&nbsp;</a></span>Remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool cerata::Remove </td>
          <td>(</td>
          <td class="paramtype">std::deque&lt; std::shared_ptr&lt; T &gt;&gt; *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove an item from a deque, returning false if it was not in the deque, true otherwise. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the item </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The deque </td></tr>
    <tr><td class="paramname">item</td><td>The item to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if item was in list and got removed, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="utils_8h_source.html#l00079">79</a> of file <a class="el" href="utils_8h_source.html">utils.h</a>.</p>

</div>
</div>
<a id="a6c2f514434950d956373e060498c2d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c2f514434950d956373e060498c2d22">&#9670;&nbsp;</a></span>ToRawPointers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt;T *&gt; cerata::ToRawPointers </td>
          <td>(</td>
          <td class="paramtype">const std::deque&lt; std::shared_ptr&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a list of shared pointers to raw pointers. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the objects being pointed to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list of shared pointers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of raw pointers. </dd></dl>

<p class="definition">Definition at line <a class="el" href="utils_8h_source.html#l00096">96</a> of file <a class="el" href="utils_8h_source.html">utils.h</a>.</p>

</div>
</div>
<a id="aebdc6582879f663d160513ad82388086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebdc6582879f663d160513ad82388086">&#9670;&nbsp;</a></span>ToRawPointers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt;T *&gt; cerata::ToRawPointers </td>
          <td>(</td>
          <td class="paramtype">const std::deque&lt; std::unique_ptr&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a list of unique pointers to raw pointers. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the objects being pointed to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list of unique pointers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of raw pointers. </dd></dl>

<p class="definition">Definition at line <a class="el" href="utils_8h_source.html#l00111">111</a> of file <a class="el" href="utils_8h_source.html">utils.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecerata.html">cerata</a></li>
    <li class="footer">Generated on Tue Oct 8 2019 10:57:39 for Cerata by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
